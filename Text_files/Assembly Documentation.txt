General info:
Character RGB values are limited to 8bit pallete (256 colors)
Character space is limited X: 0 - 106, Y: 0 - 60 (Resolution now is 640x480)
Comments can be written with //, that line is ignored
Main memory size is 16,000,000 bytes
vRam size is 16,000,000 bytes
HDD size is 16,728,100 bytes

--------------------------------------------------------------------------------------

You have data sections so you can do:
data.s         //Needed if you want variables
s8 x 5         //Variable x with type of 1 byte and stored value 5
s8.a y 3 1 2 3 //Array y with type of 2 byte elements (3 of them) with values 1 2 and 3

Data types:
s8 - 8 bit number
d16 - 16 bit number
l32 - 32 bit number
s8.a - array of 8 bit numbers
s8.g - 8 bit number on vRam
(more coming soon...)

--------------------------------------------------------------------------------------

You can set jump postions for jmp instructions

forward:

You define jump positions by typing the name of it and putting a colon at the end of it

--------------------------------------------------------------------------------------

You can do regA...regL for using register values as arguments for instructions

--------------------------------------------------------------------------------------

You need to put >program.start< at where you want the CPU to start executing
the code

--------------------------------------------------------------------------------------

You need to put interrupt.s and interrupt.e like this before program.start,
it is a must to have both of these

interrupt.s
//Instuctions here
interrupt.e

program.start

Interrupt type is stored in the 13th register (regInter) and interrupt data is
stored in special registers (interRegA...interRegH) which can be accessed with
>moveI< (moveI interRegA regA). You cannot write to interrupt data registers

--------------------------------------------------------------------------------------

CPU timer (clock) is stored in 14th registed and acces by regTimer, can be used as any other
register but is set to the current cpu tick every tick

--------------------------------------------------------------------------------------

Instruction set:
--For >move< instructions, first argument is origin data location and second
argument is target data location

move.s - Move 8 bits of data from a register to an adress in memory or move 8
bits of data from an adress in memory to a register (move.s x regA)

move.d - Move 16 bits of data from a register to an adress in memory or move
16 bits of data from an adress in memory to a register (move.d x regA)

move.l - Move 32 bits of data from a register to an adress in memory or move
32 bits of data from an adress in memory to a register (move.l x regA)

--For >moveO< instructions, same argument rules apply as for >move<
instructions but offset argument goes after the memory adress argument, not
the register argument

moveO.s - Move 8 bits of data from a register to an adress in memory with an
offset or move 8 bits of data from an adress in memory with an offset to a
register (moveO.s x offset regA)

move.g.s - Same as move.s, just accessing the vRam and not Ram (no .d and .l yet)
moveO.g.s - Same as moveO.s, just accessing the vRam and not Ram (no .d and .l yet)

--For >move.h< instructions, same argument rules apply as for >move<
instructions but offset argument goes after the memory adress argument, not
the register argument

move.h.s - Same as move.s, just accessing the HDD and not Ram

--For the following instructions you put the register you want to perform on
as the argument

clr - Set a register to 0 (clr regA)

inc - Increment the value in a register (inc regA)

dec - Decrement the value in a register (dec regA)

cot - Display the value in a register to the console (cot regA)

add - Sum two values in two registers, result is stored in the first register
(add regA regB)

mod - Modulo two values in two registers, result is stored in the first register
(mod regA regB)

sub - Subtract two values in two registers, result is stored in the first
register (sub regA regB)

mlt.s - Signed multiplication of values in two registers, result is stored in
first register (mlt.s regA regB)

mlt.u - Unsigned multiplication of values in two registers, result is stored
in first register (mlt.u regA regB)

div.s - Signed integer division of values in two registers, result is stored in first
register (div.s regA regB)

div.u - Unsigned integer division of values in two registers, result is stored in
first register (div.y regA regB)

jmp.z - Jump to given memory adress if value in register is 0 (jmp.z regA
start)

jmp.o - Jump to given memory adress if value in register is 1 (jmp.o regA
start)

jmp.u - Jump to given memory adress, jump is performed no matter the value in
register (jmp.u start)

cmp.s.b - Compare if first register holds a greater value than second register
in signed mode, result is stored in first register (cmp.s.b regA regB)

cmp.s.be - Compare if first register golds a greater or equal value than
second regisrer in signed mode, result is stored in first register (cmp.s.be
regA regB)

cmp.s.e - Compare if first and second register hold the same value, result is
stored in first register (cmp.s.e regA regB)

cmp.u.b - Compare if first register holds a greater value than second register
in unsigned mode, result is stored in first register (cmp.u.b regA regB)

cmp.u.be - Compare if first register golds a greater or equal value than
second register in unsigned mode, result is stored in first register (cmp.u.be
regA regB)

gpu.str - Start the GPU program, first and second register hold the X and Y
size of the program (gpu.str regA regB)

sb.setID - Set character ID in the screen buffer held in the GPU, first and
second register hold the x and y value and third argument is value that is
going to be set (sb.setID regA regB x)

sb.setCB - Set the character background color in the screen buffer held in the
GPU, first and second register hold the x and y value and third argument is
the value that is going to be set (sb.setCB regA regB x)

sb.setCF - Set the charater foreground color in the screen buffer held in the
GPU, first and second register hold the x and y value and third argument is
the value that is going to be set (sb.setCF regA regB x)

sb.update - Updates the character bufffer, no arguments needed

stop - Shuts down the vPC and saves the HDD to a file. Stop is a must at the end of
a program, else the vPC will work incorrectly (Assembler will warn you if you didn't
put one)

Colors go from 0-255, a picture is in the folder same as vPC that shows all
the color options

--------------------------------------------------------------------------------------

Character codes:
0:  0,  -: 21,  C: 42,  X: 63,  p: 84
1:  1,  ,: 22,  D: 43,  Y: 64,  q: 85
2:  2,  .: 23,  E: 44,  Z: 65,  r: 86
3:  3,  /: 24,  F: 45,  _: 66,  s: 87
4:  4,  \: 25,  G: 46,   : 67,  t: 88
5:  5,  :: 26,  H: 47,  @: 68,  u: 89
6:  6,  ;: 27,  I: 48,  a: 69,  v: 90
7:  7,  <: 28,  J: 49,  b: 70,  w: 91
8:  8,  >: 29,  K: 50,  c: 71,  x: 92
9:  9,  =: 30,  L: 51,  d: 72,  y: 93
!: 10,  ?: 31,  M: 52,  e: 73,  z: 94
": 11,  [: 32,  N: 53,  f: 74,
#: 12,  ]: 33,  O: 54,  g: 75,
$: 13,  {: 34,  P: 55,  h: 76,
%: 14,  }: 35,  Q: 56,  i: 77,
&: 15,  `: 36,  R: 57,  j: 78,
': 16,  ^: 37,  S: 58,  k: 79,
(: 17,  |: 38,  T: 59,  l: 80,
): 18,  ~: 39,  U: 60,  m: 81,
*: 19,  A: 40,  V: 61,  n: 82,
+: 20,  B: 41,  W: 62,  o: 83,

Key codes:
return:       95, F1:  106, F12:       117, up:     128,
tab:          96, F2:  107, esc:       118, left:   129,
caps lock:    97, F3:  108, prt sc:    119, down:   130,
left shift:   98, F4:  109, scr lk:    120, right:  131
left ctrl:    99, F5:  110, pause:     121,
left alt:    100, F6:  111. insert:    122,
space:       101, F7:  112, home:      123,
right alt:   102, F8:  113. page up:   124,
right ctrl:  103, F9:  114, delte:     125,
right shift: 104, F10: 115, end:       126,
backspace:   105, F11: 116, page down: 127,
